<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_191) on Wed Dec 11 23:28:26 AST 2019 -->
<title>CarpetExpression</title>
<meta name="date" content="2019-12-11">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="CarpetExpression";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">carpet.script</div>
<h2 title="Class CarpetExpression" class="title">Class CarpetExpression</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>carpet.script.CarpetExpression</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">CarpetExpression</span>
extends java.lang.Object</pre>
<div class="block"><h1>Minecraft specific API and <code>scarpet</code> language add-ons and commands</h1>
 <p>Here is the gist of the Minecraft related functions. Otherwise the CarpetScript could live without Minecraft.</p>
 <h2>Dimension warning</h2>
 <p>One note, which is important is that most of the calls for entities and blocks
 would refer to the current dimension of the caller, meaning, that if we for example
 list all the players using <code>player('all')</code> function, if a player is in the
 other dimension, calls to entities and blocks around that player would point incorrectly.
 Moreover, running commandblocks in the spawn chunks would mean that commands will always
 refer to the overworld blocks and entities.
 In case you would want to run commands across all dimensions, just run three of them, using
 <code>/execute in overworld/the_nether/the_end run script run ...</code> and query
 players using <code>player('*')</code>, which only returns players in current dimension, or use
 <code>in_dimension(expr)</code> function.</p></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#CarpetExpression-java.lang.String-net.minecraft.server.command.ServerCommandSource-net.minecraft.util.math.BlockPos-">CarpetExpression</a></span>(java.lang.String&nbsp;expression,
                net.minecraft.server.command.ServerCommandSource&nbsp;source,
                net.minecraft.util.math.BlockPos&nbsp;origin)</code>
<div class="block">.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#API_AuxiliaryAspects--">API_AuxiliaryAspects</a></span>()</code>
<div class="block">Auxiliary aspects</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#API_BlockManipulation--">API_BlockManipulation</a></span>()</code>
<div class="block">Blocks / World API</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#API_EntityManipulation--">API_EntityManipulation</a></span>()</code>
<div class="block">Entity API</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#API_InventoryManipulation--">API_InventoryManipulation</a></span>()</code>
<div class="block">Inventory and Items API</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#API_IteratingOverAreasOfBlocks--">API_IteratingOverAreasOfBlocks</a></span>()</code>
<div class="block">Iterating over larger areas of blocks</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#BreakExecutionOfAllScriptsWithCommands-boolean-">BreakExecutionOfAllScriptsWithCommands</a></span>(boolean&nbsp;doStop)</code>
<div class="block"><code>script stop/script resume</code> command</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#fillAndScanCommand-carpet.script.ScriptHost-int-int-int-">fillAndScanCommand</a></span>(carpet.script.ScriptHost&nbsp;host,
                  int&nbsp;x,
                  int&nbsp;y,
                  int&nbsp;z)</code>
<div class="block"><code>/script scan</code>, <code>/script fill</code> and <code>/script outline</code> commands</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#gameEventsSystem--">gameEventsSystem</a></span>()</code>
<div class="block">Scarpet events system</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#invokeGlobalFunctionCommand--">invokeGlobalFunctionCommand</a></span>()</code>
<div class="block"><code>/script invoke / invokepoint / invokearea</code>, <code>/script globals</code> commands</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#loadScriptsFromFilesCommand--">loadScriptsFromFilesCommand</a></span>()</code>
<div class="block"><code>/script load / unload &lt;app&gt; (global?)</code>, <code>/script in &lt;app&gt;</code> commands</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#scriptRunCommand-carpet.script.ScriptHost-net.minecraft.util.math.BlockPos-">scriptRunCommand</a></span>(carpet.script.ScriptHost&nbsp;host,
                net.minecraft.util.math.BlockPos&nbsp;pos)</code>
<div class="block"><code>/script run</code> command</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="CarpetExpression-java.lang.String-net.minecraft.server.command.ServerCommandSource-net.minecraft.util.math.BlockPos-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>CarpetExpression</h4>
<pre>public&nbsp;CarpetExpression(java.lang.String&nbsp;expression,
                        net.minecraft.server.command.ServerCommandSource&nbsp;source,
                        net.minecraft.util.math.BlockPos&nbsp;origin)</pre>
<div class="block"><h1>.</h1></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expression</code> - expression</dd>
<dd><code>source</code> - source</dd>
<dd><code>origin</code> - origin</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="API_AuxiliaryAspects--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_AuxiliaryAspects</h4>
<pre>public&nbsp;void&nbsp;API_AuxiliaryAspects()</pre>
<div class="block"><h1>Auxiliary aspects</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>Collection of other methods that control smaller, yet still important aspects of the game</p>
 <h2>Sounds</h2>
 <h3><code>sound(name, pos, volume?, pitch?)</code></h3>
 <p>Plays a specific sound <code>name</code>, at block or position <code>pos</code>, with optional
 <code>volume</code> and modified <code>pitch</code>. <code>pos</code> can be either a block, triple of coords,
 or a list of thee numbers. Uses the same options as a corresponding <code>playsound</code> command.</p>
 <h2>Particles</h2>
 <h3><code>particle(name, pos, count?. spread?, speed?, playername?)</code></h3>
 <p>Renders a cloud of particles <code>name</code> centered around <code>pos</code> position, by default
 <code>count</code> 10 of them, default <code>speed</code> of 0, and to all players nearby, but these
 options can be changed via optional arguments. Follow vanilla <code>/particle</code> command on details on those
 options. Valid particle names are for example
 <code>'angry_villager', 'item diamond', 'block stone', 'dust 0.8 0.1 0.1 4'</code></p>
 <h3><code>particle_line(name, pos, pos2, density?)</code></h3>
 <p>Renders a line of particles from point <code>pos</code> to <code>pos2</code> with supplied density (defaults 1),
 which indicates how far part you would want particles to appear, so <code>0.1</code> means one every 10cm.</p>
 <h3><code>particle_rect(name, pos, pos2, density?)</code></h3>
 <p>Renders a cuboid of particles between point <code>pos</code> to <code>pos2</code> with supplied density.</p>
 <h2>Markers</h2>
 <h3><code>create_marker(text, pos, rotation?, block?)</code></h3>
 <p>Spawns a (permanent) marker entity with text or block at position. Returns that entity for further manipulations.
 Unloading the app that spawned them will cause all the markers from the loaded portion of the world to be removed.
 Also - if the game loads that marker in the future and the app is not loaded, it will be removed as well.</p>
 <h3><code>remove_all_markers()</code></h3>
 <p>Removes all scarpet markers from the loaded portion of the world created by this app, in case you didn't want
 to do the proper cleanup</p>
 <h2>System function</h2>
 <h3><code>nbt(expr)</code></h3>
 <p>Treats the argument as a nbt serializable string and returns its nbt value.
 In case nbt is not in a correct nbt compound tag format, it will return <code>null</code> value.</p>
 <p>Consult section about container operations in <code>Expression</code> to learn about possible operations on nbt values.</p>
 <h3><code>escape_nbt(expr)</code></h3>
 <p>Excapes all the special characters in the string or nbt tag and returns a string that can be stored in nbt directly as
 a string value.</p>
 <h3><code>print(expr)</code></h3>
 <p>Displays the result of the expression to the chat. Overrides default <code>scarpet</code> behaviour of
 sending everyting to stderr.</p>
 <h3><code>logger(expr)</code></h3>
 <p>Prints the message to system logs, and not to chat.</p>
 <h3><code>run(expr)</code></h3>
 <p>Runs a vanilla command <code>expr</code> and returns its success count</p>
 <pre>
 run('fill 1 1 1 10 10 10 air') -&gt; 10 // 10 block were filled, this operation was successful 10 times out of a possible 1000 blocks volume
 run('give @s stone 4') -&gt; 1 // this operation was successful once
 </pre>
 <h3><code>save()</code></h3>
 <p>Performs autosave, saves all chunks, player data, etc. Useful for programs where autosave is disabled
 due to performance reasons and saves the world only on demand.</p>
 <h3><code>load_app_data(), load_app_data(file)</code></h3>
 <p>Loads the app data associated with the app from the world /scripts folder. Without argument returns the memory
 managed and buffered / throttled NBT tag. With a file name - reads explicitly a file with that name from the scripts
 floder.</p>
 <p> You can use app data to save non-vanilla information separately from the world and other scripts.</p>
 <h3><code>store_app_data(tag), store_app_data(tag, file)</code></h3>
 <p>Stores the app data associated with the app from the world /scripts folder. With the <code>file</code> parameter
 saves immediately and with every call, without <code>file</code> parameter, it may take up to 10 seconds for the output
 file to sync preventing flickering in case this tag changes frequently. It will be synced when server closes.</p>
 <h3><code>tick_time()</code></h3>
 <p>Returns game tick counter. Can be used to run certain operations every n-th ticks, or to count in-game time</p>
 <h3><code>game_tick(mstime?)</code></h3>
 <p>Causes game to run for one tick. By default runs it and returns control to the program, but can optionally
 accept expected tick length, in milliseconds. You can't use it to permanently change the game speed, but
 setting longer commands with custom tick speeds can be interrupted via <code>/script stop</code> command</p>
 <pre>
 loop(1000,tick())  // runs the game as fast as it can for 1000 ticks
 loop(1000,tick(100)) // runs the game twice as slow for 1000 ticks
 </pre>
 <h3><code>current_dimension()</code></h3>
 <p>Returns current dimension that the script runs in.</p>
 <h3><code>in_dimension(smth, expr)</code></h3>
 <p>Evaluates the expression <code>expr</code> with different dimension execution context. <code>smth</code> can
 be an entity, world-localized block, so not <code>block('stone')</code>, or a string representing a dimension like:
 <code>'nether'</code>, <code>'the_nether'</code>, <code>'end'</code> or <code>'overworld'</code>, etc.</p>
 <h3><code>schedule(delay, function, args...)</code></h3>
 <p>Schedules a user defined function to run with a specified <code>delay</code> ticks of delay.
 Scheduled functions run at the end of the tick, and they will run in order they were scheduled.</p>
 <h3><code>plop(pos, what)</code></h3>
 <p>Plops a structure or a feature at a given <code>pos</code>, so block, triple position coordinates
 or a list of coordinates. To <code>what</code> gets plopped and exactly where it often depends on the
 feature or structure itself. For example, all structures are chunk aligned, and often span multiple chunks.
 Repeated calls to plop a structure in the same chunk would result either in the same strucuture generated on
 top of each other, or with different state, but same position. Most
 structures generate at specific altitudes, which are hardcoded, or with certain blocks around them. API will cancel
 all extra position / biome / random requirements for structure / feature placement, but some hardcoded limitations
 may still cause some of strucutures/features not to place. Some features require special blocks to be present, like
 coral -&gt; water or ice spikes -&gt; snow block, and for some features, like fossils, placement is all sorts of
 messed up.</p>
 <p>
 All generated structures will retain their properties, like mob spawning, however in many cases the world / dimension
 itself has certain rules to spawn mobs, like plopping a nether fortress in the overworld will not spawn nether mobs
 because nether mobs can spawn only in the nether, but plopped in the nether - will behave like a valid nether
 fortress.</p>
 <p><code>plop</code>  will not use world random number generator to generate structures and features, but its own.
 This has a benefit that they will generate properly randomly, not the same time every time</p>
 <p>Structure list:</p>
 <ul>

     <li><code>monument</code>: Ocean Monument. Generates at fixed Y coordinate, surrounds itself with water.</li>
     <li><code>fortress</code>: Nether Fortress. Altitude varies, but its bounded by the code.</li>
     <li><code>mansion</code>: Woodland Mansion</li>
     <li><code>jungle_temple</code>: Jungle Temple</li>
     <li><code>desert_temple</code>: Desert Temple. Generates at fixed Y altitude.</li>
     <li><code>end_city</code>: End City with Shulkers</li>
     <li><code>igloo</code>: Igloo</li>
     <li><code>shipwreck</code>: Shipwreck, version1?</li>
     <li><code>shipwreck2</code>: Shipwreck, version2?</li>
     <li><code>witchhut</code></li>
     <li><code>oceanruin, oceanruin_small, oceanruin_tall</code>: Stone variants of ocean ruins.</li>
     <li><code>oceanruin_warm, oceanruin_warm_small, oceanruin_warm_tall</code>: Sandstone variants of ocean ruins.</li>
     <li><code>treasure</code>: A treasure chest. Yes, its a whole structure.</li>
     <li><code>pillager_outpost</code>: A pillager outpost.</li>
     <li><code>mineshaft</code>: A mineshaft.</li>
     <li><code>mineshaft_mesa</code>: A Mesa (Badlands) version of a mineshaft.</li>
     <li><code>village</code>: Plains, oak village.</li>
     <li><code>village_desert</code>: Desert, sandstone village.</li>
     <li><code>village_savanna</code>: Savanna, acacia village.</li>
     <li><code>village_taiga</code>: Taiga, spruce village.</li>
     <li><code>village_snowy</code>: Resolute, Canada.</li>
 </ul>
 <p>Feature list:</p>
 <ul>
     <li><code>oak</code></li>
     <li><code>oak_beehive</code>: oak with a hive (1.15+).</li>
     <li><code>oak_large</code>: oak with branches.</li>
     <li><code>oak_large_beehive</code>: oak with branches and a beehive (1.15+).</li>
     <li><code>birch</code></li>
     <li><code>birch_large</code>: tall variant of birch tree.</li>
     <li><code>shrub</code>: low bushes that grow in jungles.</li>
     <li><code>shrub_acacia</code>: low bush but configured with acacia (1.14 only)</li>
     <li><code>shrub_snowy</code>: low bush with white blocks (1.14 only)</li>
     <li><code>jungle</code>: a tree</li>
     <li><code>jungle_large</code>: 2x2 jungle tree</li>
     <li><code>spruce</code></li>
     <li><code>spruce_large</code>: 2x2 spruce tree</li>
     <li><code>pine</code>: spruce with minimal leafage (1.15+)</li>
     <li><code>pine_large</code>: 2x2 spruce with minimal leafage (1.15+)</li>
     <li><code>spruce_matchstick</code>: see 1.15 pine (1.14 only).</li>
     <li><code>spruce_matchstick_large</code>: see 1.15 pine_large (1.14 only).</li>
     <li><code>dark_oak</code></li>
     <li><code>acacia</code></li>
     <li><code>oak_swamp</code>: oak with more leaves and vines.</li>


     <li><code>well</code>: desert well</li>
     <li><code>grass</code>: a few spots of tall grass</li>
     <li><code>grass_jungle</code>: little bushier grass feature (1.14 only)</li>
     <li><code>lush_grass</code>: grass with patchy ferns (1.15+)</li>
     <li><code>tall_grass</code>: 2-high grass patch (1.15+)</li>
     <li><code>fern</code>: a few random 2-high ferns</li>
     <li><code>cactus</code>: random cacti</li>
     <li><code>dead_bush</code>: a few random dead bushi</li>
     <li><code>fossils</code>: underground fossils, placement little wonky</li>
     <li><code>mushroom_brown</code>: large brown mushroom.</li>
     <li><code>mushroom_red</code>: large red mushroom.</li>
     <li><code>ice_spike</code>: ice spike. Require snow block below to place.</li>
     <li><code>glowstone</code>: glowstone cluster. Required netherrack above it.</li>
     <li><code>melon</code>: a patch of melons</li>
     <li><code>melon_pile</code>: a pile of melons (1.15+)</li>
     <li><code>pumpkin</code>: a patch of pumpkins</li>
     <li><code>pumpkin_pile</code>: a pile of pumpkins (1.15+)</li>
     <li><code>sugarcane</code></li>
     <li><code>lilypad</code></li>
     <li><code>dungeon</code>: Dungeon. These are hard to place, and fail often.</li>
     <li><code>iceberg</code>: Iceberg. Generate at sea level.</li>
     <li><code>iceberg_blue</code>: Blue ice iceberg.</li>
     <li><code>lake</code></li>
     <li><code>lava_lake</code></li>
     <li><code>end_island</code></li>
     <li><code>chorus</code>: Chorus plant. Require endstone to place.</li>
     <li><code>sea_grass</code>: a patch of sea grass. Require water.</li>
     <li><code>sea_grass_river</code>: a variant.</li>
     <li><code>kelp</code></li>
     <li><code>coral_tree, coral_mushroom, coral_claw</code>: various coral types, random color.</li>
     <li><code>coral</code>: random coral structure. Require water to spawn.</li>
     <li><code>sea_pickle</code></li>
     <li><code>boulder</code>: A rocky, mossy formation from a giant taiga biome. Doesn't update client properly,
     needs relogging.</li>
 </ul>
 </div></div>
</li>
</ul>
<a name="API_BlockManipulation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_BlockManipulation</h4>
<pre>public&nbsp;void&nbsp;API_BlockManipulation()</pre>
<div class="block"><h1>Blocks / World API</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <h2>Specifying blocks</h2>
 <h3><code>block(x, y, z), block(l(x,y,z)), block(state)</code></h3>
 <p>Returns either a block from specified location, or block with a specific state
 (as used by <code>/setblock</code> command), so allowing for block properties, block entity data etc.
 Blocks otherwise can be referenced everywhere by its simple string name, but its only used in its default state</p>
 <pre>
 block('air')  =&gt; air
 block('iron_trapdoor[half=top]')  =&gt; iron_trapdoor
 block(0,0,0) == block('bedrock')  =&gt; 1
 block('hopper[facing=north]{Items:[{Slot:1b,id:"minecraft:slime_ball",Count:16b}]}') =&gt; hopper
 </pre>
 <p>Retrieving a block with <code>block</code> function has also a side-effect of evaluating its current state and data.
 so if you use it later it will reflect block state and data of the block that was when block was called, rather than
 when it was used. Block values passed in various places like <code>scan</code> functions, etc, are not fully evaluated
 unless its properties are needed. This means that if the block at the location changes before its queried in the program
 this might result in getting the later state, which might not be desired. Consider the following example:</p>
 <pre>
 set(10,10,10,'stone');
 scan(10,10,10,0,0,0, b = _);
 set(10,10,10,'air');
 print(b); // 'air', block was remembered 'lazily', and evaluated by `print`, when it was already set to air

 set(10,10,10,'stone');
 scan(10,10,10,0,0,0, b = block(_));
 set(10,10,10,'air');
 print(b); // 'stone', block was evaluated 'eagerly' but call to `block`

 </pre>
 <h2>World Manipulation</h2>
 <p>All the functions below can be used with block value, queried with coord triple, or 3-long list.
 All <code>pos</code> in the functions referenced below refer to either method of passing block position</p>
 <h3><code>set(pos, block, property?, value?, ...)</code></h3>
 <p>First part of the <code>set</code> function is either a coord triple, list of three numbers, or other block
 with coordinates. Second part, <code>block</code> is either block value as a result of <code>block()</code> function
 string value indicating the block name, and optional <code>property - value</code> pairs for extra block properties.
 If <code>block</code> is specified only by name, then if a destination block is the same the <code>set</code> operation
 is skipped, otherwise is executed, for other potential extra properties</p>
 <p>The returned value is either the block state that has been set, or <code>false</code> if block setting was skipped</p>
 <pre>
 set(0,5,0,'bedrock')  =&gt; bedrock
 set(l(0,5,0), 'bedrock')  =&gt; bedrock
 set(block(0,5,0), 'bedrock')  =&gt; bedrock
 scan(0,5,0,0,0,0,set(_,'bedrock'))  =&gt; 1
 set(pos(players()), 'bedrock')  =&gt; bedrock
 set(0,0,0,'bedrock')  =&gt; 0   // or 1 in overworlds generated in 1.8 and before
 scan(0,100,0,20,20,20,set(_,'glass'))
     // filling the area with glass
 scan(0,100,0,20,20,20,set(_,block('glass')))
     // little bit faster due to internal caching of block state selectors
 b = block('glass'); scan(0,100,0,20,20,20,set(_,b))
     // yet another option, skips all parsing
 set(x,y,z,'iron_trapdoor')  // sets bottom iron trapdoor
 set(x,y,z,'iron_trapdoor[half=top]')  // Incorrect. sets bottom iron trapdoor - no parsing of properties
 set(x,y,z,'iron_trapdoor','half','top') // correct - top trapdoor
 set(x,y,z,block('iron_trapdoor[half=top]')) // also correct, block() provides extra parsing
 set(x,y,z,'hopper[facing=north]{Items:[{Slot:1b,id:"minecraft:slime_ball",Count:16b}]}') // extra block data
 </pre>
 <h3><code>place_item(item, pos, facing?, sneak?)</code></h3>
 <p>Places a given item in the world like it was placed by a player. Item names are default minecraft item name,
 less the minecraft prefix. Default facing is 'up', but there are other options: 'down', 'north', 'east',
 'south', 'west', but also there are other secondary directions important for placement of blocks like stairs, doors, etc.
 Try experiment with options like 'north-up' which is placed facing north with cursor pointing to the upper part of the block,
 or 'up-north', which means a block placed facing up (player looking down) and placed smidge away of the block center
 towards north. Optional sneak is a boolean indicating if a player would be sneaking while placing the block -
 this option only affects placement of chests and scaffolding at the moment.
 Returns true if placement was successful, false otherwise.</p>
 <pre>
     place_item('stone',x,y,z) // places a stone block on x,y,z block
     place_item('piston,x,y,z,'down') // places a piston facing down
     place_item('carrot',x,y,z) // attempts to plant a carrot plant. Returns true if could place carrots at that position.
 </pre>
 <h3><code>biome(pos)</code></h3>
 <p>returns biome at that block position.</p>
 <h3><code>set_biome(pos, biome_name)</code></h3>
 <p>changes biome at that block position.</p>
 <h3><code>update(pos)</code></h3>
 <p>Causes a block update at position.</p>
 <h3><code>block_tick(pos)</code></h3>
 <p>Causes a block to tick at position.</p>
 <h3><code>random_tick(pos)</code></h3>
 <p>Causes a random tick at position.</p>
 <h3><code>destroy(pos), destroy(pos, -1), destroy(pos, &lt;N&gt;)</code></h3>
 <p>Destroys the block like it was mined by a player. Add -1 for silk touch, and positive number for fortune level.
 This function, unlike harvest, will affect all kinds of blocks</p>
 <h3><code>harvest(player, pos)</code></h3>
 <p>Causes a block to be harvested by a specified player entity. Honors player item enchantments, as well as damages the
 tool if applicable. If the entity is not a valid player, no block gets destroyed. If a player is not allowed to
 break that block, a block doesn't get destroyed either.</p>

 <h2>Block and World querying</h2>

 <h3><code>pos(block), pos(entity)</code></h3>
 <p>Returns a triple of coordinates of a specified block or entity. Technically entities are queried with
 <code>query</code> function and the same can be achieved with <code>query(entity,'pos')</code>, but for simplicity
 <code>pos</code> allows to pass all positional objects.</p>
 <pre>
     pos(block(0,5,0))  =&gt; l(0,5,0)
     pos(players()) =&gt; l(12.3, 45.6, 32.05)
     pos(block('stone'))  =&gt; Error: Cannot fetch position of an unrealized block
 </pre>
 <h3><code>pos_offset(pos, direction, amount?)</code></h3>
 <p>Returns a coords triple that is offset in a specified <code>direction</code> by <code>amount</code> of blocks.
 The default offset amount is 1 block. To offset into opposite facing, use negative numbers for the <code>amount</code>.
 </p>
 <pre>
     pos_offset(block(0,5,0), 'up', 2)  =&gt; l(0,7,0)
     pos_offset(l(0,5,0), 'up', -2 ) =&gt; l(0,3,0)
 </pre>
 <h3><code>block_properties(pos)</code></h3>
 <p>Returns a list of available block properties for a particular block. If a block has no properties, returns an empty list.</p>
 <h3><code>property(pos, name)</code></h3>
 <p>Returns property of block at <code>pos</code>, or specified by <code>block</code> argument. If a block doesn't
 have that property, <code>null</code> value is returned. Returned values are always strings. It is expected from
 the user to know what to expect and convert values to numbers using <code>number()</code> function or booleans
 using <code>bool()</code> function.</p>
 <pre>
     set(x,y,z,'iron_trapdoor','half','top'); property(x,y,z,'half')  =&gt; top
     set(x,y,z,'air'); property(x,y,z,'half')  =&gt; null
     property(block('iron_trapdoor[half=top]'),'half')  =&gt; top
     property(block('iron_trapdoor[half=top]'),'powered')  =&gt; false
     bool(property(block('iron_trapdoor[half=top]'),'powered'))  =&gt; 0
 </pre>
 <h3><code>block_data(pos)</code></h3>
 <p>Return NBT string associated with specific location, or null if the block does not carry block data.
 Can be currently used to match specific information from it, or use it to copy to another block</p>
 <pre>
     block_data(x,y,z) =&gt; '{TransferCooldown:0,x:450,y:68, ... }'
 </pre>
 <h3><code>solid(pos)</code></h3>
 <p>Boolean function, true if the block is solid</p>
 <h3> <code>air(pos)</code></h3>
 <p>Boolean function, true if a block is air.... or cave air...
 or void air.... or any other air they come up with.</p>
 <h3><code>liquid(pos)</code></h3>
 <p>Boolean function, true if the block is liquid, or liquidlogged</p>
 <h3><code>flammable(pos)</code></h3>
 <p>Boolean function, true if the block is flammable</p>
 <h3><code>transparent(pos)</code></h3>
 <p>Boolean function, true if the block is transparent</p>
 <h3><code>opacity(pos)</code></h3>
 <p>Numeric, returning opacity level of a block</p>
 <h3><code>blocks_daylight(pos)</code></h3>
 <p>Boolean function, true if the block blocks daylight</p>
 <h3><code>emitted_light(pos)</code></h3>
 <p>Numeric, returning light level emitted from block</p>
 <h3><code>light(pos)</code></h3>
 <p>Integer function, returning total light level at position</p>
 <h3><code>block_light(pos)</code></h3>
 <p>Integer function, returning block light at position. From torches and other light sources.</p>
 <h3><code>sky_light(pos)</code></h3>
 <p>Numeric function, returning sky light at position. From the sky access.</p>
 <h3><code>see_sky(pos)</code></h3>
 <p>Boolean function, returning true if the block can see sky.</p>
 <h3><code>hardness(pos)</code></h3>
 <p>Numeric function, indicating hardness of a block.</p>
 <h3><code>blast_resistance(pos)</code></h3>
 <p>Numeric function, indicating blast_resistance of a block.</p>

 <h3><code>top(type, pos)</code></h3>
 <p>Returns the Y value of the topmost block at given x, z coords (y value of a block is not important), according to the
 heightmap specified by <code>type</code>. Valid options are:</p>
 <ul>
     <li><code>light</code>: topmost light blocking block (1.13 only)</li>
     <li><code>motion</code>: topmost motion blocking block</li>
     <li><code>terrain</code>: topmost motion blocking block except leaves</li>
     <li><code>ocean_floor</code>: topmost non-water block</li>
     <li><code>surface</code>: topmost surface block</li>
 </ul>
 <pre>
 top('motion', x, y, z)  =&gt; 63
 top('ocean_floor', x, y, z)  =&gt; 41
 </pre>
 <h3><code>loaded(pos)</code></h3>
 <p>Boolean function, true if the block is accessible forthe game mechanics.
 Normally <code>scarpet</code> doesn't check if operates on
 loaded area - the game will automatically load missing blocks. We see this as advantage.
 Vanilla <code>fill/clone</code> commands only check the specified corners for loadness.</p>
 <p>To check if block is truly loaded, I mean in memory, use <code>generation_status(x) != null</code>, as
 chunks can still be loaded outside of the playable area, just are not used any of the game mechanics processes.</p>
 <pre>
 loaded(pos(players()))  =&gt; 1
 loaded(100000,100,1000000)  =&gt; 0
 </pre>
 <h3><code>(Deprecated) loaded_ep(pos)</code></h3>
 <p>Boolean function, true if the block is loaded and entity processing, as per 1.13.2</p>
 <p>Deprecated as of scarpet 1.6, use <code>loaded_status(x) &gt; 0</code>, or
 just <code>loaded(x)</code> with the same effect</p>
 <h3><code>loaded_status(pos)</code></h3>
 <p>Returns loaded status as per new 1.14 chunk ticket system, 0 for inaccessible, 1 for border chunk,
 2 for ticking, 3 for entity ticking</p>
 <h3><code>generation_status(pos), generation_status(pos, true)</code></h3>
 <p>Returns generation status as per new 1.14 chunk ticket system. Can return any value from several available
 but chunks can only be valid in a few states: <code>full</code>, <code>features</code>, <code>liquid_carvers</code>,
 and <code>structure_starts</code>. Returns <code>null</code> if the chunk is not in memory unless called with optional
 <code>true</code>.</p>
 <h3><code>suffocates(pos)</code></h3>
 <p>Boolean function, true if the block causes suffocation.</p>
 <h3><code>power(pos)</code></h3>
 <p>Numeric function, returning redstone power level at position.</p>
 <h3><code>ticks_randomly(pos)</code></h3>
 <p>Boolean function, true if the block ticks randomly.</p>
 <h3><code>blocks_movement(pos)</code></h3>
 <p>Boolean function, true if block at position blocks movement.</p>
 <h3><code>block_sound(pos)</code></h3>
 <p>Returns the name of sound type made by the block at position. One of:</p>
 <ul>
     <li><code>wood     </code>  </li>
     <li><code>gravel   </code>  </li>
     <li><code>grass    </code>  </li>
     <li><code>stone    </code>  </li>
     <li><code>metal    </code>  </li>
     <li><code>glass    </code>  </li>
     <li><code>wool     </code>  </li>
     <li><code>sand     </code>  </li>
     <li><code>snow     </code>  </li>
     <li><code>ladder   </code>  </li>
     <li><code>anvil    </code>  </li>
     <li><code>slime    </code>  </li>
     <li><code>sea_grass</code>  </li>
     <li><code>coral    </code>  </li>
 </ul>
 <h3><code>material(pos)</code></h3>
 <p>Returns the name of material of the block at position. very useful to target a group of blocks. One of:</p>
 <ul>
     <li><code> air                </code>  </li>
     <li><code> void               </code>  </li>
     <li><code> portal             </code>  </li>
     <li><code> carpet             </code>  </li>
     <li><code> plant              </code>  </li>
     <li><code> water_plant        </code>  </li>
     <li><code> vine               </code>  </li>
     <li><code> sea_grass          </code>  </li>
     <li><code> water              </code>  </li>
     <li><code> bubble_column      </code>  </li>
     <li><code> lava               </code>  </li>
     <li><code> snow_layer         </code>  </li>
     <li><code> fire               </code>  </li>
     <li><code> redstone_bits      </code>  </li>
     <li><code> cobweb             </code>  </li>
     <li><code> redstone_lamp      </code>  </li>
     <li><code> clay               </code>  </li>
     <li><code> dirt               </code>  </li>
     <li><code> grass              </code>  </li>
     <li><code> packed_ice         </code>  </li>
     <li><code> sand               </code>  </li>
     <li><code> sponge             </code>  </li>
     <li><code> wood               </code>  </li>
     <li><code> wool               </code>  </li>
     <li><code> tnt                </code>  </li>
     <li><code> leaves             </code>  </li>
     <li><code> glass              </code>  </li>
     <li><code> ice                </code>  </li>
     <li><code> cactus             </code>  </li>
     <li><code> stone              </code>  </li>
     <li><code> iron               </code>  </li>
     <li><code> snow               </code>  </li>
     <li><code> anvil              </code>  </li>
     <li><code> barrier            </code>  </li>
     <li><code> piston             </code>  </li>
     <li><code> coral              </code>  </li>
     <li><code> gourd              </code>  </li>
     <li><code> dragon_egg         </code>  </li>
     <li><code> cake               </code>  </li>
 </ul>
 <h3><code>map_colour(pos)</code></h3>
 <p>Returns the map colour of a block at position. One of:</p>
 <ul>
     <li><code> air            </code>  </li>
     <li><code> grass          </code>  </li>
     <li><code> sand           </code>  </li>
     <li><code> wool           </code>  </li>
     <li><code> tnt            </code>  </li>
     <li><code> ice            </code>  </li>
     <li><code> iron           </code>  </li>
     <li><code> foliage        </code>  </li>
     <li><code> snow           </code>  </li>
     <li><code> clay           </code>  </li>
     <li><code> dirt           </code>  </li>
     <li><code> stone          </code>  </li>
     <li><code> water          </code>  </li>
     <li><code> wood           </code>  </li>
     <li><code> quartz         </code>  </li>
     <li><code> adobe          </code>  </li>
     <li><code> magenta        </code>  </li>
     <li><code> light_blue     </code>  </li>
     <li><code> yellow         </code>  </li>
     <li><code> lime           </code>  </li>
     <li><code> pink           </code>  </li>
     <li><code> gray           </code>  </li>
     <li><code> light_gray     </code>  </li>
     <li><code> cyan           </code>  </li>
     <li><code> purple         </code>  </li>
     <li><code> blue           </code>  </li>
     <li><code> brown          </code>  </li>
     <li><code> green          </code>  </li>
     <li><code> red            </code>  </li>
     <li><code> black          </code>  </li>
     <li><code> gold           </code>  </li>
     <li><code> diamond        </code>  </li>
     <li><code> lapis          </code>  </li>
     <li><code> emerald        </code>  </li>
     <li><code> obsidian       </code>  </li>
     <li><code> netherrack     </code>  </li>
     <li><code> white_terracotta          </code>  </li>
     <li><code> orange_terracotta         </code>  </li>
     <li><code> magenta_terracotta        </code>  </li>
     <li><code> light_blue_terracotta     </code>  </li>
     <li><code> yellow_terracotta         </code>  </li>
     <li><code> lime_terracotta           </code>  </li>
     <li><code> pink_terracotta           </code>  </li>
     <li><code> gray_terracotta           </code>  </li>
     <li><code> light_gray_terracotta     </code>  </li>
     <li><code> cyan_terracotta           </code>  </li>
     <li><code> purple_terracotta         </code>  </li>
     <li><code> blue_terracotta           </code>  </li>
     <li><code> brown_terracotta          </code>  </li>
     <li><code> green_terracotta          </code>  </li>
     <li><code> red_terracotta            </code>  </li>
     <li><code> black_terracotta          </code>  </li>
 </ul>
 </div></div>
</li>
</ul>
<a name="API_EntityManipulation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_EntityManipulation</h4>
<pre>public&nbsp;void&nbsp;API_EntityManipulation()</pre>
<div class="block"><h1>Entity API</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <h2>Entity Selection</h2>
 <p>Entities have to be fetched before using them. Entities can also change their state between calls to the script
 if game happens either in between separate calls to the programs, or if the program calls <code>game_tick</code>
 on its own. In this case - entities would need to be re-fetched, or the code should account for entities getting dead</p>
 <h3><code>player(), player(type), player(name)</code></h3>
 <p>
 With no arguments, it returns the calling player or the player closest to the caller. Note that the main context
 will receive <code>p</code> variable pointing to this player. With <code>type</code> or <code>name</code> specified
 it will try first to match a type, returning a list of players matching a type, and if this fails, will assume its
 player name query retuning player with that name, or <code>null</code> if no player was found.
 With <code>'all'</code>, list of all players in the game, in all dimensions, so end user needs to be cautious, that
 you might be referring to wrong blocks and entities around the player in question.
 WIth <code>type = '*'</code> it returns all players in caller dimension, <code>'survival'</code> returns all survival
 and adventure players, <code>'creative'</code> returns all creative players, <code>'spectating'</code> returns all spectating
 players, and <code>'!spectating'</code>, all not-spectating players. If all fails,
 with <code>name</code>, the player in question, if is logged in.</p>
 <h3><code>entity_id(uuid), entity_id(id)</code></h3>
 <p>Fetching entities wither by their ID obtained via <code>entity ~ 'id'</code>, which is unique
 for a dimension and current world run, or by UUID, obtained via <code>entity ~ 'uuid'</code>.
 It returns null if no such entity
 is found. Safer way to 'store' entities between calls, as missing entities will be returning <code>null</code>.
 Both calls using UUID or numerical ID are <code>O(1)</code>, but obviously using UUIDs takes more memory and compute.</p>
 <h3><code>entity_list(type)</code></h3>
 <p>Returns global lists of entities in the current dimension of a specified type. Currently the following selectors are available:</p>
 <ul>
     <li><code>*</code>: all</li>
     <li><code>living</code></li>
     <li><code>items</code></li>
     <li><code>players</code></li>
     <li><code>!players</code></li>
 </ul>

 <h3><code>entity_area(type, cx, cy, cz, dx, dy, dz)</code></h3>
 <p>Returns entities of a specified type in an area centered on <code>cx, cy, cz</code> and
 at most <code>dx, dy, dz</code> blocks away from the center point. Uses same selectors as <code>entities_list</code></p>

 <h3><code>entity_selector(selector)</code></h3>
 <p>Returns entities satisfying given vanilla entity selector. Most complex among all the methods of selecting
 entities, but the most capable. Selectors are cached so should be as fast as other methods of selecting entities.</p>

 <h3><code>spawn(name, pos, nbt?)</code></h3>
 <p>Spawns and places an entity in world, like <code>/summon</code> vanilla command.
 Requires a position to spawn, and optional extra nbt data to merge with the entity. What makes it different from calling
 <code>run('summon ...')</code>, is the fact that you get the entity back as a return value, which is swell.</p>

 <h2>Entity Manipulation</h2>

 <p>Unlike with blocks, that use plethora of vastly different querying functions, entities are queried with
 <code>query</code> function and altered via <code>modify</code> function. Type of information needed or
 values to be modified are different for each call</p>
 <p>Using <code>~</code> (in) operator is an alias for <code>query</code>. Especially useful if a statement has
 no arguments, which in this case can be radically simplified</p>
 <pre>
     query(p, 'name') &lt;=&gt; p ~ 'name'     // much shorter and cleaner
     query(p, 'holds', 'offhand') &lt;=&gt; p ~ l('holds', 'offhand')    // not really but can be done
 </pre>
 <h3><code>query(e,'removed')</code></h3>
 <p>Boolean. True if the entity is removed</p>
 <h3><code>query(e,'id')</code></h3>
 <p>Returns numerical id of the entity. Most efficient way to keep track of entites in a script. Ids are only unique
 within current game session (ids are not preserved between restarts), and dimension (each dimension has its own ids
 which can overlap. </p>
 <h3><code>query(e,'uuid')</code></h3>
 <p>Returns UUID (unique id) of the entity. Can be used to access entities with the other vanilla commands and remains unique
 regardless of the dimension, and is preserved between game restarts.
 Apparently players cannot be accessed via UUID, but name instead.</p>
 <pre>
 map(entities_area('*',x,y,z,30,30,30),run('kill '+query(_,'id'))) // doesn't kill the player
 </pre>
 <h3><code>query(e,'pos')</code></h3>
 <p>Triple of entity position</p>
 <h3><code>query(e,'location')</code></h3>
 <p>Quin-tuple of entity position (x, y, and z coords), and rotation (yaw, pitch)</p>
 <h3><code>query(e,'x'), query(e,'y'), query(e,'z')</code></h3>
 <p>Respective entity coordinate</p>
 <h3><code>query(e,'pitch'), query(e,'yaw')</code></h3>
 <p>Pitch and Yaw or where entity is looking.</p>
 <h3><code>query(e,'look')</code></h3>
 <p>Returns a 3d vector where the entity is looking.</p>
 <h3><code>query(e,'motion')</code></h3>
 <p>Triple of entity motion vector, <code>l(motion_x, motion_y, motion_z)</code></p>
 <h3><code>query(e,'motion_x'), query(e,'motion_y'), query(e,'motion_z')</code></h3>
 <p>Respective component of the motion vector</p>
 <h3><code>query(e,'name'), query(e,'custom_name'), query(e,'type')</code></h3>
 <p>String of entity name</p>
 <pre>
 query(e,'name')  =&gt; Leatherworker
 query(e,'custom_name')  =&gt; null
 query(e,'type')  =&gt; villager
 </pre>
 <h3><code>query(e,'is_riding')</code></h3>
 <p>Boolean. True if riding another entity.</p>
 <h3><code>query(e,'is_ridden')</code></h3>
 <p>Boolean. True if another entity is riding it.</p>
 <h3><code>query(e,'passengers')</code></h3>
 <p>List of entities riding the entity.</p>
 <h3><code>query(e,'mount')</code></h3>
 <p>Entity that <code>e</code> rides.</p>
 <h3><code>query(e,'tags')</code></h3>
 <p>List of entity tags.</p>
 <h3><code>query(e,'has_tags',tag)</code></h3>
 <p>Boolean, True if the entity is marked with <code>tag</code>.</p>
 <h3><code>query(e,'is_burning')</code></h3>
 <p>Boolean, True if the entity is burning.</p>
 <h3><code>query(e,'fire')</code></h3>
 <p>Number of remaining ticks of being on fire.</p>
 <h3><code>query(e,'silent')</code></h3>
 <p>Boolean, True if the entity is silent.</p>
 <h3><code>query(e,'gravity')</code></h3>
 <p>Boolean, True if the entity is affected by gravity, like most entities do.</p>
 <h3><code>query(e,'immune_to_fire')</code></h3>
 <p>Boolean, True if the entity is immune to fire.</p>
 <h3><code>query(e,'dimension')</code></h3>
 <p>Name of the dimension entity is in.</p>
 <h3><code>query(e,'height')</code></h3>
 <p>Height of the entity.</p>
 <h3><code>query(e,'width')</code></h3>
 <p>Width of the entity.</p>
 <h3><code>query(e,'eye_height')</code></h3>
 <p>Eye height of the entity.</p>
 <h3><code>query(e,'age')</code></h3>
 <p>Age, in ticks, of the entity, i.e. how long it existed.</p>
 <h3><code>query(e,'despawn_timer')</code></h3>
 <p>For living entities - the number of ticks they fall outside of immediate player presence.</p>
 <h3><code>query(e,'item')</code></h3>
 <p>The item triple (name, count, nbt) if its an item entity, <code>null</code> otherwise</p>
 <h3><code>query(e,'count')</code></h3>
 <p>Number of items in a stack from item entity, <code>null</code> otherwise</p>
 <h3><code>query(e,'pickup_delay')</code></h3>
 <p>Retrieves pickup delay timeout for an item entity, <code>null</code> otherwise</p>
 <h3><code>query(e,'is_baby')</code></h3>
 <p>Boolean, true if its a baby.</p>
 <h3><code>query(e,'target')</code></h3>
 <p>Returns mob's attack target or null if none or not applicable.</p>
 <h3><code>query(e,'home')</code></h3>
 <p>Returns creature's home position or null if none or not applicable.</p>
 <h3><code>query(e,'sneaking')</code></h3>
 <p>Boolean, true if entity is sneaking.</p>
 <h3><code>query(e,'sprinting')</code></h3>
 <p>Boolean, true if entity is sprinting.</p>
 <h3><code>query(e,'swimming')</code></h3>
 <p>Boolean, true if entity is swimming.</p>
 <h3><code>query(e,'jumping')</code></h3>
 <p>Boolean, true if entity is jumping.</p>
 <h3><code>query(e,'gamemode')</code></h3>
 <p>String with gamemode, or <code>null</code> if not a player.</p>
 <h3><code>query(e,'gamemode_id')</code></h3>
 <p>Good'ol gamemode id, or null if not a player.</p>
 <h3><code>query(e,'effect',name?)</code></h3>
 <p>Without extra arguments, it returns list of effect active on a living entity.
 Each entry is a triple of short effect name, amplifier, and remaining duration.
 With an argument, if the living entity has not that potion active, returns <code>null</code>, otherwise
 return a tuple of amplifier and remaining duration</p>
 <pre>
 query(p,'effect')  =&gt; [[haste, 0, 177], [speed, 0, 177]]
 query(p,'effect','haste')  =&gt; [0, 177]
 query(p,'effect','resistance')  =&gt; null
 </pre>
 <h3><code>query(e,'health')</code></h3>
 <p>Number indicating remaining entity health, or <code>null</code> if not applicable.</p>

 <h3><code>query(e,'holds',slot?)</code></h3>
 <p>Returns triple of short name, stack count, and NBT of item held in <code>slot</code>.
 Available options for <code>slot</code> are:</p>
 <ul>
     <li><code>mainhand</code></li>
     <li><code>offhand</code></li>
     <li><code>head</code></li>
     <li><code>chest</code></li>
     <li><code>legs</code></li>
     <li><code>feet</code></li>
 </ul>
 <p>If <code>slot</code> is not specified, it defaults to the main hand.</p>
 <h3><code>query(e,'selected_slot')</code></h3>
 <p>Number indicating the selected slot of entity inventory. Currently only applicable to players.</p>
 <h3><code>query(e,'facing', order?)</code></h3>
 <p>Returns where the entity is facing. optional order (number from 0 to 5, and negative), indicating
 primary directions where entity is looking at. From most prominent (order 0) to opposite (order 5, or -1)</p>
 <h3><code>query(e,'trace', reach?, options?...)</code></h3>
 <p>Returns the result of ray tracing from entity perspective, indicating what it is looking at. Default reach is 4.5
 blocks (5 for creative players), and by default it traces for blocks and entities, identical to player attack tracing action.
 This can be customized with <code>options</code>, use 'blocks' to trace for blocks only, 'liquids' to include liquid blocks
 as possible results, and 'entities' to trace entities as well.</p>
 <p>Regardless of the options selected, the result could be <code>null</code> if nothing is in reach, entity, if look
 targets an antity, and block value if block is in reach. Tracing always hits blocks. Even if an entity tracing is requested
 and there is a block in the way - the block will be returned.</p>
 <h3><code>query(e,'nbt',path?)</code></h3>
 <p>Returns full NBT of the entity. If path is specified, it fetches only that portion of the NBT,
 that corresponds to the path. For specification of <code>path</code> attribute, consult
 vanilla <code>/data get entity</code> command.</p>
 <p>Note that calls to <code>nbt</code> are considerably more expensive comparing to other
 calls in Minecraft API, and should only be used when there is no other option. Returned value is of type <code>nbt</code>,
 which can be further manipulated with nbt type objects via <code>get, put, has, delete</code>, so try to use API calls
 first for that.</p>
 <h2>Entity Modification</h2>
 <p>Like with entity querying, entity modifications happen through one function. Most position and movements
 modifications don't work currently on players as their position is controlled by clients.</p>
 <p>Currently there is no ability to modify NBT directly, but you could always use <code>run('data modify entity</code></p>
 <h3><code>modify(e,'remove')</code></h3>
 <p>Removes (not kills) entity from the game.</p>
 <h3><code>modify(e,'kill')</code></h3>
 <p>Kills the entity.</p>
 <h3><code>modify(e, 'pos', x, y, z), modify(e, 'pos', l(x,y,z) )</code></h3>
 <p>Moves the entity to a specified coords.</p>
 <h3><code>modify(e, 'location', x, y, z, yaw, pitch), modify(e, 'location', l(x, y, z, yaw, pitch) )</code></h3>
 <p>Changes full location vector all at once.</p>
 <h3><code>modify(e, 'x', x), modify(e, 'y', y), modify(e, 'z', z)</code></h3>
 <p>Moves the entity in.... one direction.</p>
 <h3><code>modify(e, 'pitch', pitch), modify(e, 'yaw', yaw)</code></h3>
 <p>Changes entity's pitch or yaw.</p>
 <h3><code>modify(e, 'move', x, y, z), modify(e, 'move', l(x,y,z) )</code></h3>
 <p>Moves the entity by a vector from its current location.</p>
 <h3><code>modify(e, 'motion', x, y, z), modify(e, 'motion', l(x,y,z) )</code></h3>
 <p>Sets the motion vector (where and how much entity is moving).</p>
 <h3><code>modify(e, 'motion_z', x), modify(e, 'motion_y', y), modify(e, 'motion_z', z)</code></h3>
 <p>Sets the corresponding component of the motion vector.</p>
 <h3><code>modify(e, 'accelerate', x, y, z), modify(e, 'accelerate', l(x, y, z) )</code></h3>
 <p>Adds a vector to the motion vector. Most realistic way to apply a force to an entity.</p>
 <h3><code>modify(e, 'custom_name'), modify(e, 'custom_name', name )</code></h3>
 <h3><code>modify(e, 'pickup_delay')</code></h3>
 <p>Sets a custom pickup delay if the entity argument is an item entity</p>
 <h3><code>modify(e, 'despawn_timer')</code></h3>
 <p>Sets a custom despawn timer value.</p>
 <h3><code>modify(e, 'dismount')</code></h3>
 <p>Dismounts riding entity.</p>
 <h3><code>modify(e, 'mount', other)</code></h3>
 <p>Mounts the entity to the <code>other</code>.</p>
 <h3><code>modify(e, 'drop_passengers')</code></h3>
 <p>Shakes off all passengers.</p>
 <h3><code>modify(e, 'mount_passengers', passenger, ? ...), modify(e, 'mount_passengers', l(passengers) )</code></h3>
 <p>Mounts on all listed entities on <code>e</code>.</p>
 <h3><code>modify(e, 'tag', tag, ? ...), modify(e, 'tag', l(tags) )</code></h3>
 <p>Adds tag / tags to the entity.</p>
 <h3><code>modify(e, 'clear_tag', tag, ? ...), modify(e, 'clear_tag', l(tags) )</code></h3>
 <p>Removes tag from entity.</p>
 <h3><code>modify(e, 'talk')</code></h3>
 <p>Make noises.</p>
 <h3><code>modify(e, 'ai', boolean)</code></h3>
 <p>If called with <code>false</code> value, it will disable AI in the mob. <code>true</code> will enable it again.</p>
 <h3><code>modify(e, 'home', null), modify(e, 'home', block, distance?), modify(e, 'home', x, y, z, distance?)</code></h3>
 <p>Sets AI to stay around the home position, within <code>distance</code> blocks from it. <code>distance</code>
 defaults to 16 blocks. <code>null</code> removes it. <i>May</i> not work fully with mobs that have this AI built in, like
 Villagers.</p>

 <h2>Entity Events</h2>
 <p>There is a number of events that happen to entities that you can attach your own code to in the form of event
 handlers. The event handler is any function that runs in your package that accepts certain expected parameters, which
 you can expand with your own arguments. When it comes to the moment when the given command needs to be executed, it
 does so providing that number of arguments it accepts is equal number of event arguments, and extra arguments passed when
 defining the callback with <code>entity_event</code></p>
 <p>The following events can be handled by entities. </p>
 <ul>
     <li><code>'on_tick'</code>: executes every tick right before entity is ticked in the game. Required arguments: <code>entity</code></li>
     <li><code>'on_death'</code>: executes once when a living entity dies. Required arguments: <code>entity, reason</code></li>
     <li><code>'on_removed'</code>: execute once when an entity is removed. Required arguments: <code>entity</code></li>
     <li><code>'on_damaged'</code>: executed every time a living entity is about to receive damage. Required arguments:  <code>entity, amount, source, attacking_entity</code></li>
 </ul>
 <p>It doesn't mean that all entity types will have a chance to
 execute a given event, but entities will not error when you will attach inapplicable event to it.</p>
 <h3><code>entity_event(e, event, call_name, args...)</code></h3>
 <p>Attaches specific function from the current package to be called upon the <code>event</code>, with extra <code>args</code>
 curried to the original required arguments for the event handler</p>
 <pre>
 protect_villager(entity, amount, source, source_entity, healing_player) -&gt;
 (
         if(source_entity &amp;&amp; source_entity~'type' != 'player',
           modify(entity, 'health', amount + entity~'health' );
           particle('end_rod', pos(entity)+l(0,3,0));
           print(str('%s healed thanks to %s', entity, healing_player))
         )
 );

 __on_player_interacts_with_entity(player, entity, hand) -&gt;
 (
   if (entity~'type' == 'villager',
           entity_event(entity, 'on_damage', 'protect_villager', player~'name')
   )
 )
 </pre>
 <p>In this case this will protect a villager from entity damage (zombies, etc.) except players by granting all the health
 back to the villager after being harmed.</p>
 </div></div>
</li>
</ul>
<a name="API_InventoryManipulation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_InventoryManipulation</h4>
<pre>public&nbsp;void&nbsp;API_InventoryManipulation()</pre>
<div class="block"><h1>Inventory and Items API</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <h2>Manipulating inventories of blocks and entities</h2>
 <p>Most functions in this category require inventory as the first argument. Inventory could be specified by
 an entity, or a block, or position (three coordinates) of a potential block with inventory.
 If the entity or a block doesn't
 have an inventory, they typically do nothing and return null.</p>
 <p>Most items returned are in the form of
 a triple of item name, count, and nbt or the extra data associated with an item.
 Manipulating of the nbt data can be costly, but retrieving them from the tuple to match other aspects is cheap</p>
 <h3><code>stack_limit(item)</code></h3>
 <p>Returns number indicating what is the stack limit for the item. Its typically 1 (non-stackable),
 16 (like buckets), or 64 - rest. It is recommended to consult this, as other inventory API functions
 ignore normal stack limits, and it is up to the programmer to keep it at bay. As of 1.13, game checks for negative
 numbers and setting an item to negative is the same as empty.</p>
 <pre>
     stack_limit('wooden_axe') =&gt; 1
     stack_limit('ender_pearl') =&gt; 16
     stack_limit('stone') =&gt; 64
 </pre>
 <h3><code>item_category(item)</code></h3>
 <p>Returns the string representing the category of a given item, like `building_blocks`, `combat`, or `tools`.</p>
 <pre>
     item_category('wooden_axe') =&gt; tools
     item_category('ender_pearl') =&gt; misc
     item_category('stone') =&gt; building_blocks
 </pre>
 <h3><code>inventory_size(inventory)</code></h3>
 <p>Returns the size of the inventory for the entity or block in question. Returns null if the block or entity
 don't have an inventory</p>
 <pre>
     inventory_size(player()) =&gt; 41
     inventory_size(x,y,z) =&gt; 27 // chest
     inventory_size(block(pos)) =&gt; 5 // hopper
 </pre>
 <h3><code>inventory_has_items(inventory)</code></h3>
 <p>Returns true, if the inventory is not empty, false if it is empty, and null, if its not an inventory.</p>
 <pre>
     inventory_has_items(player()) =&gt; true
     inventory_has_items(x,y,z) =&gt; false // empty chest
     inventory_has_items(block(pos)) =&gt; null // stone
 </pre>
 <h3><code>inventory_get(inventory, slot)</code></h3>
 <p>Returns the item in the corresponding inventory slot, or null if slot empty or inventory is invalid.
 You can use negative numbers to indicate slots counted from 'the back'.</p>
 <pre>
     inventory_get(player(), 0) =&gt; null // nothing in first hotbar slot
     inventory_get(x,y,z, 5) =&gt; ['stone', 1, {}]
     inventory_get(player(), -1) =&gt; ['diamond_pickaxe', 1, {Damage:4}] // slightly damaged diamond pick in the offhand
 </pre>

 <h3><code>inventory_set(inventory, slot, count, item?, nbt?) </code></h3>
 <p>Modifies or sets a stack in inventory. specify count 0 to empty the slot.
 If item is not specified, keeps existing item, just modifies the count. If item is provided - replaces current item.
 If nbt is provided - adds a tag to the stack at slot. Returns previous stack in that slot.</p>
 <pre>
     inventory_set(player(), 0, 0) =&gt; ['stone', 64, {}] // player had a stack of stone in first hotbar slot
     inventory_set(player(), 0, 6) =&gt; ['diamond', 64, {}] // changed stack of diamonds in player slot to 6
     inventory_set(player(), 0, 1, 'diamond_axe','{Damage:5}') =&gt; null //added slightly damaged pick to first player slot
 </pre>

 <h3><code>inventory_find(inventory, item, start_slot?, ), inventory_find(inventory, null, start_slot?) </code></h3>
 <p>Finds the first slot with a corresponding item in the inventory, or if queried with null: the first empty slot.
 Returns slot number if found, or null otherwise. Optional start_slot argument allows to skip all preceeding slots
 allowing for efficient (so not slot-by-slot) inventory search for items.</p>
 <pre>
     inventory_find(player(), 'stone') =&gt; 0 // player has stone in first hotbar slot
     inventory_find(player(), null) =&gt; null // player's inventory has no empty spot
     while( (slot = inventory_find(p, 'diamond', slot)) != null, 41, drop_item(p, slot) )
         // spits all diamonds from player inventory wherever they are
     inventory_drop(x,y,z, 0) =&gt; 64 // removed and spawned in the world a full stack of items
 </pre>

 <h3><code>inventory_remove(inventory, item, amount?) </code></h3>
 <p>Removes amount (defaults to 1) of item from inventory. If the inventory doesn't have the defined amount, nothing
 happens, otherwise the given amount of items is removed wherever they are in the inventory. Returns boolean whether
 the removal operation was successful. Easiest way to remove a specific item from player inventory without specifying
 the slot.</p>
 <pre>
     inventory_remove(player(), 'diamond') =&gt; 1 // removed diamond from player inventory
     inventory_remove(player(), 'diamond', 100) =&gt; 0 // player doesn't have 100 diamonds, nothing happened
 </pre>

 <h3><code>drop_item(inventory, slot, amount?, )</code></h3>
 <p>Drops the items from indicated inventory slot, like player that Q's an item or villager, that exchanges food.
 You can Q items from block inventories as well. default amount is 0 - which is all from the slot. NOTE: hoppers are quick
 enough to pick all the queued items from their inventory anyways.
 Returns size of the actual dropped items.</p>
 <pre>
     inventory_drop(player(), 0, 1) =&gt; 1 // Q's one item on the ground
     inventory_drop(x,y,z, 0) =&gt; 64 // removed and spawned in the world a full stack of items
 </pre>
 </div></div>
</li>
</ul>
<a name="API_IteratingOverAreasOfBlocks--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_IteratingOverAreasOfBlocks</h4>
<pre>public&nbsp;void&nbsp;API_IteratingOverAreasOfBlocks()</pre>
<div class="block"><h1>Iterating over larger areas of blocks</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>These functions help scan larger areas of blocks without using generic loop functions,
 like nested <code>loop</code>.</p>
 <h2> </h2>
 <h3><code>scan(cx, cy, cz, dx, dy, dz, px?, py?, pz?, expr)</code></h3>
 <p>Evaluates expression over area of blocks defined by its center (<code>cx, cy, cz</code>),
 expanded in all directions by <code>dx, dy, dz</code> blocks, or optionally in negative with <code>d</code> coords,
 and <code>p</code> coords in positive values. <code>expr</code> receives <code>_x, _y, _z</code>
 as coords of current analyzed block and <code>_</code> which represents the block itself.</p>
 <h3><code>volume(x1, y1, z1, x2, y2, z2, expr)</code></h3>
 <p>Evaluates expression for each block in the area, the same as the <code>scan</code>function, but using two opposite
 corners of the rectangular cuboid. Any corners can be specified, its like you would do with <code>/fill</code> command</p>
 <h3><code>neighbours(x, y, z), neighbours(block), neighbours(l(x,y,z))</code></h3>
 <p>Returns the list of 6 neighbouring blocks to the argument. Commonly used with other loop functions like <code>for</code></p>
 <pre>
 for(neighbours(x,y,z),air(_)) =&gt; 4 // number of air blocks around a block
 </pre>
 <h3><code>rect(cx, cy, cz, dx?, dy?, dz?, px?, py?, pz?)</code></h3>
 <p>returns an iterator, just like <code>range</code> function that iterates over rectangular cubarea of blocks. If
 only center point is specified, it iterates over 27 blocks. If <code>d</code> arguments are specified, expands selection
 of respective number of blocks in each direction. If <code>p</code> arguments are specified, it uses <code>d</code> for
 negative offset, and <code>p</code> for positive.</p>
 <h3><code>diamond(cx, cy, cz, radius?, height?)</code></h3>
 <p>Iterates over a diamond like area of blocks. With no radius and height, its 7 blocks centered around the middle
 (block + neighbours). With a radius specified, it expands shape on x and z coords, and with a custom height, on y. Any of these can be
 zero as well. radius of 0 makes a stick, height of 0 makes a diamond shape pad.</p>
 </div></div>
</li>
</ul>
<a name="BreakExecutionOfAllScriptsWithCommands-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BreakExecutionOfAllScriptsWithCommands</h4>
<pre>public&nbsp;void&nbsp;BreakExecutionOfAllScriptsWithCommands(boolean&nbsp;doStop)</pre>
<div class="block"><h1><code>script stop/script resume</code> command</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>
 <code>/script stop</code> allows to stop execution of any script currently running that calls the
 <code>gametick()</code> function which
 allows the game loop to regain control of the game and process other commands. This will also make sure
 that all current and future programs will stop their execution. Execution of all programs will be
 prevented until <code>/script resume</code> command is called.
 </p>
 <p>Lets look at the following example. This is a program computes Fibonacci number in a recursive manner:</p>
 <pre>
 fib(n) -&gt; if(n&lt;3, 1, fib(n-1)+fib(n-2) ); fib(8)
 </pre>
 <p> That's really bad way of doing it, because the higher number we need to compute the compute requirements will rise
 exponentially with <code>n</code>. It takes a little over 50 milliseconds to do fib(24), so above one tick,
 but about a minute to do fib(40). Calling fib(40) will not only freeze the game, but also you woudn't be able to interrupt
 its execution. We can modify the script as follows</p>
 <pre>fib(n) -&gt; ( gametick(50); if(n&lt;3, 1, fib(n-1)+fib(n-2) ) ); fib(40)</pre>
 <p>But this would never finish as such call would finish after <code>~ 2^40</code> ticks. To make our computations
 responsive, yet able to respond to user interactions, other commands, as well as interrupt execution,
 we could do the following:</p>
 <pre>fib(n) -&gt; ( if(n==23, gametick(50) ); if(n&lt;3, 1, fib(n-1)+fib(n-2) ) ); fib(40)</pre>
 <p>This would slow down the computation of fib(40) from a minute to two, but allows the game to keep continue running
 and be responsive to commands, using about half of each tick to advance the computation.
 Obviously depending on the problem, and available hardware, certain things can take
 more or less time to execute, so portioning of work with calling <code>gametick</code> should be balanced in each
 case separately</p>
 </div></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doStop</code> - .</dd>
</dl>
</li>
</ul>
<a name="fillAndScanCommand-carpet.script.ScriptHost-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillAndScanCommand</h4>
<pre>public&nbsp;boolean&nbsp;fillAndScanCommand(carpet.script.ScriptHost&nbsp;host,
                                  int&nbsp;x,
                                  int&nbsp;y,
                                  int&nbsp;z)</pre>
<div class="block"><h1><code>/script scan</code>, <code>/script fill</code> and <code>/script outline</code> commands</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>These commands can be used to evaluate an expression over an area of blocks. They all need to have specified
 the origin of the analyzed area (which is used as referenced (0,0,0), and two corners of an area to analyzed. If
 you would want that the script block coordinates refer to the actual world coordinates, use origin of <code>0 0 0</code>,
 or if it doesn't matter, duplicating coordinates of one of the corners is the easiest way.</p>
 <p>These commands, unlike raw <code>/script run </code> are limited by vanilla fill / clone command
 limit of 32k blocks, which can be altered with carpet mod's own <code>/carpet fillLimit</code> command.</p>
 <h2></h2>
 <h3><code>/script scan origin&lt;x y z&gt;  corner&lt;x y z&gt; corner&lt;x y z&gt; expr</code></h3>
 <p>Evaluates expression for each point in the area and returns number of successes (result was positive). Since
 the command by itself doesn't affect the area, the effects would be in side effects.</p>
 <h3><code>/script fill origin&lt;x y z&gt;  corner&lt;x y z&gt; corner&lt;x y z&gt; "expr" &lt;block&gt; (? replace &lt;replacement&gt;) </code></h3>
 <p>Think of it as a regular fill command, that sets blocks based on whether a result of the command was successful.
 Note that the expression is in quotes. Thankfully string constants in <code>scarpet</code> use single quotes. Can be used
 to fill complex geometric shapes.</p>
 <h3><code>/script outline origin&lt;x y z&gt;  corner&lt;x y z&gt; corner&lt;x y z&gt; "expr" &lt;block&gt; (? replace &lt;replacement&gt;) </code></h3>
 <p>Similar to <code>fill</code> command it evaluates an expression for each block in the area, but in this case setting blocks
 where condition was true and any of the neighbouring blocks were evaluated negatively. This allows to create surface areas,
 like sphere for example, without resorting to various rounding modes and tricks.</p>
 <p>Here is an example of seven ways to draw a sphere of radius of 32 blocks around 0 100 0: </p>
 <pre>
 /script outline 0 100 0 -40 60 -40 40 140 40 "x*x+y*y+z*z &lt;  32*32" white_stained_glass replace air
 /script outline 0 100 0 -40 60 -40 40 140 40 "x*x+y*y+z*z &lt;= 32*32" white_stained_glass replace air
 /script outline 0 100 0 -40 60 -40 40 140 40 "x*x+y*y+z*z &lt;  32.5*32.5" white_stained_glass replace air
 /script fill    0 100 0 -40 60 -40 40 140 40 "floor(sqrt(x*x+y*y+z*z)) == 32" white_stained_glass replace air
 /script fill    0 100 0 -40 60 -40 40 140 40 "round(sqrt(x*x+y*y+z*z)) == 32" white_stained_glass replace air
 /script fill    0 100 0 -40 60 -40 40 140 40 "ceil(sqrt(x*x+y*y+z*z)) == 32" white_stained_glass replace air
 /draw sphere 0 100 0 32 white_stained_glass replace air

 fluffy ball round(sqrt(x*x+y*y+z*z)-rand(abs(y)))==32

 </pre>
 <p>The last method is the one that world edit is using (part of carpet mod). It turns out that the outline method with <code>32.5</code> radius,
 fill method with <code>round</code> function and draw command are equivalent</p>
 </div></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>host</code> - .</dd>
<dd><code>x</code> - .</dd>
<dd><code>y</code> - .</dd>
<dd><code>z</code> - .</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>.</dd>
</dl>
</li>
</ul>
<a name="gameEventsSystem--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gameEventsSystem</h4>
<pre>public&nbsp;void&nbsp;gameEventsSystem()</pre>
<div class="block"><h1>Scarpet events system</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>Provides the ability to execute specific function whenever an event occurs. The functions to be registered
 need to conform with the arguments to the event specification. When loading module functions, each function that
 starts with <code>__on_...</code> and has the required arguments, will be bound automatically.
 In case of player specific modules, all player action events will be directed to the appropriate player space, and
 all tick events will be executed in the global context, so its not a good idea to mix these two, so use either of these,
 or use commands to call tick events directly, or handle player specific data inside a module.</p>
 <h2></h2>
 <h3>Event list</h3>
 <p>Here is a list of events that can be handled by scarpet. This list includes prefixes required by modules to
 autoload them, but you can add any function to any event if it accepts required number of parameters:</p>
 <pre>
 __on_tick()         // can access blocks and entities in the overworld
 __on_tick_nether()  // can access blocks and entities in the nether
 __on_tick_ender()   // can access blocks and entities in the end

 // player specific callbacks
 __on_player_uses_item(player, item_tuple, hand)  // right click action
 __on_player_releases_item(player, item_tuple, hand)  // client action (e.g. bow)
 __on_player_finishes_using_item(player, item_tuple, hand))  // server action (e.g. food), called item is from before it is used.
 __on_player_clicks_block(player, block, face)  // left click attack on a block
 __on_player_right_clicks_block(player, item_tuple, hand, block, face, hitvec)
 __on_player_breaks_block(player, block) // called after block is broken (the caller receives previous blockstate)
 __on_player_interacts_with_entity(player, entity, hand)
 __on_player_attacks_entity(player, entity)
 __on_player_rides(player, forward, strafe, jumping, sneaking)
 __on_player_jumps(player)
 __on_player_deploys_elytra(player)
 __on_player_wakes_up(player)
 __on_player_starts_sneaking(player)
 __on_player_stops_sneaking(player)
 __on_player_starts_sprinting(player)
 __on_player_stops_sprinting(player)
 __on_player_drops_item(player)
 __on_player_drops_stack(player)
 </pre>
 <h3><code>/script event</code> command</h3>
 <p>used to display current events and bounded functions. use <code>add_to</code> ro register new event, or <code>remove_from</code>
 to unbind a specific function from an event. Function to be bounded to an event needs to have the same
 number of parameters as the action is attempting to bind to (see list above). All calls in modules
 loaded via <code>/script load</code> that have functions listed above will be automatically bounded and unbounded when
 script is unloaded.</p>
 </div></div>
</li>
</ul>
<a name="invokeGlobalFunctionCommand--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invokeGlobalFunctionCommand</h4>
<pre>public&nbsp;void&nbsp;invokeGlobalFunctionCommand()</pre>
<div class="block"><h1><code>/script invoke / invokepoint / invokearea</code>, <code>/script globals</code> commands</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p><code>invoke</code> family of commands provide convenient way to invoke stored procedures (i.e. functions
 that has been defined previously by any running script. To view current stored procedure set,
 run <code>/script globals</code>(or <code>/script globals all</code> to display all functions even hidden ones),
 to define a new stored procedure, just run a <code>/script run function(a,b) -&gt; ( ... )</code>
 command with your procedure once, and to forget a procedure, use <code>undef</code> function:
 <code>/script run undef('function')</code></p>
 <h2></h2>
 <h3><code>/script invoke &lt;fun&gt; &lt;args?&gt; ... </code></h3>
 <p>Equivalent of running <code>/script run fun(args, ...)</code>, but you get the benefit of getting the tab completion of the
 command name, and lower permission level required to run these (since player is not capable of running any custom code
 in this case, only this that has been executed before by an operator). Arguments will be checked for validity, and
 you can only pass simple values as arguments (strings, numbers, or <code>null</code> value). Use quotes to include
 whitespaces in argument strings.</p>
 <p>Command will check provided arguments with required arguments (count) and fail if not enough or too much arguments
 are provided. Operators defining functions are advised to use descriptive arguments names, as these will be visible
 for invokers and form the base of understanding what each argument does.</p>
 <p><code>invoke</code> family of commands will tab complete any stored function that does not start with <code>'_'</code>,
 it will still allow to run procedures starting with <code>'_'</code> but not suggest them, and ban execution of any
 hidden stored procedures, so ones that start with <code>'__'</code>. In case operator needs to use subroutines
 for convenience and don't want to expose them to the <code>invoke</code> callers, they can use this mechanic.</p>
 <pre>
 /script run example_function(const, phrase, price) -&gt; print(const+' '+phrase+' '+price)
 /script invoke example_function pi costs 5
 </pre>
 <h3><code>/script invokepoint &lt;fun&gt; &lt;coords x y z&gt; &lt;args?&gt; ... </code></h3>
 <p>It is equivalent to <code>invoke</code> except it assumes that the first three arguments are coordinates, and provides
 coordinates tab completion, with <code>looking at... </code> mechanics for convenience. All other arguments are expected
 at the end</p>
 <h3><code>/script invokearea &lt;fun&gt; &lt;coords x y z&gt; &lt;coords x y z&gt; &lt;args?&gt; ... </code></h3>
 <p>It is equivalent to <code>invoke</code> except it assumes that the first three arguments are one set of ccordinates,
 followed by the second set of coordinates, providing tab completion, with <code>looking at... </code> mechanics for convenience,
 followed by any other required arguments</p>
 </div></div>
</li>
</ul>
<a name="loadScriptsFromFilesCommand--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>loadScriptsFromFilesCommand</h4>
<pre>public&nbsp;void&nbsp;loadScriptsFromFilesCommand()</pre>
<div class="block"><h1><code>/script load / unload &lt;app&gt; (global?)</code>, <code>/script in &lt;app&gt;</code> commands</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p><code>load / unload</code> commands allow for very conventient way of writing your code, providing it to the game
 and distribute with your worlds without the need of use of commandblocks. Just place your scarpet code in the /scripts
 folder of your world files and make sure it ends with <code>.sc</code> extension. The good thing about editing that
 code is that you can no only use normal editing without the need of marking of newlines, but you can also use
 comments in your code.</p>
 <p> a comment is anything that starts with a double slash, and continues to the end of the line:</p>
 <pre>
 foo = 1;
 //This is a comment
 bar = 2;
 // This never worked, so I commented it out
 // baz = foo()
 </pre>
 <h2></h2>
 <h3><code>/script load/unload &lt;app&gt; (?global) </code></h3>
 <p>Loading operation will load that script code from disk and execute it right away. You would probably use it to
 load some stored procedures to be used for later. To reload the module, just type <code>/script load</code> again.
 Reloading removes all the current global state (globals and functions) that were added later by the module. </p>
 <p>Loading a module, if it contains a <code>__command()</code> method, will attempt to registed a command with that
 app name, and register all public (no underscore) functions available in the module as subcommands. It will also
 bind specific events to the event system (check Events section for details).</p>
 <p>Loaded apps have the ability to store and load external files, especially their persistent tag state.
 For that check <code>load_app_data</code> and <code>store_app_data</code> functions.</p>
 <p>If an app defines <code>__config</code> method, and that method returns a map, it will be used to apply custom
 settings for this app. Currently the following options are supported:</p>
 <ul>
     <li><code>scope</code>: default scope for global variables for the app, Default is 'player' which means
     that globals and defined functions will be unique for each player so that apps for each player will run in
     isolation. This is useful in tool-like applications. Another option is 'global' which shares global state for all
     runs on the server - applicable to 'block' like solutions, where custom behaviours are applied to blocks.</li>
     <li><code>stay_loaded</code>: defaults to false. If true, and <code>/carpet scriptsAutoload</code> is turned on,
     the following apps will stay loaded after startup. Otherwise, after reading a code, and fetching the config, server
     will drop them down. This is to allow to store multiple apps on the server/world and selectively decide which one
     should be running at startup. WARNING: all apps will run once at startup anyways, so be aware that their actions
     that are called statically, will be performed once anyways.</li>
 </ul>
 <p>Unloading an app removes all of its state from the game, disables commands, and removes bounded events</p>
 <p>Scripts can be loaded in shared(global) and player mode. Default is player, so all globals and stored functions are
 individual for each player, meaning scripts don't need to worry about making sure they store some intermittent data
 for each player independently. In global mode - all global values and stored functions are shared among all players.
 To access specific player data with commandblocks, use <code>/execute as (player) run script in (app) run ... </code>
 To access global/server state, you need to disown the command from any player, so use a commandblock, or any arbitrary
 entity: <code>/execute as @e[type=bat,limit=1] run script in (module) globals</code> for instance.
 </p>
 <h3><code>/script in &lt;app&gt; ... </code></h3>
 <p>Allows to run normal /script commands in a specific app, like <code>run, invoke,..., globals</code> etc...</p>
 </div></div>
</li>
</ul>
<a name="scriptRunCommand-carpet.script.ScriptHost-net.minecraft.util.math.BlockPos-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>scriptRunCommand</h4>
<pre>public&nbsp;java.lang.String&nbsp;scriptRunCommand(carpet.script.ScriptHost&nbsp;host,
                                         net.minecraft.util.math.BlockPos&nbsp;pos)</pre>
<div class="block"><h1><code>/script run</code> command</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>Primary way to input commands. The command executes in the context, position, and dimension of the executing
 player, commandblock, etc... The command receives 4 variables, <code>x</code>, <code>y</code>, <code>z</code>
 and <code>p</code> indicating position and the executing entity of the command.
 You will receive tab completion suggestions as you type your code suggesting functions and global variables.
 It is advisable to use <code>/execute in ... at ... as ... run script run ...</code> or similar, to simulate running
 commands in a different scope</p>
 </div></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>host</code> - .</dd>
<dd><code>pos</code> - .</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
</body>
</html>
